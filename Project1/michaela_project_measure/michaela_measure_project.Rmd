---
title: 'R Notebook Project Measure'
name: "Michaela"
email: "michaela.bayerlova@wsu.edu"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 6
    fig_caption: true
    number_sections: false 
params:
  knitChunkSetEcho: TRUE 
  knitChunkSetWarning: FALSE
  knitChunkSetMessage: TRUE
  knitChunkSetCache: TRUE
  knitChunkSetFigPath: "graphics/"
    
my-var: "monte"  # https://bookdown.org/yihui/rmarkdown/html-document.html
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning=FALSE)
```


# Loading data
```{r, chunk-file-path}
# # Run those before the whole document
# Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
# Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
# Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
# Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
library(humanVerseWSU);

path.measure = "C:/Users/michaela.bayerlova/Documents/STATS 419/measurement_project/";  
file.measure = paste0(path.measure,"measure-students.txt");

```


# Data Cleanup
## Create data frame measure
This step saves the original data in a data frame called measure.raw. Another data frame is created as well, measure.clean, which is going to be modified.
```{r, chunk-get-your-data}
# create data frame

measure.raw = read.csv(file.measure, header=TRUE, sep="|");
measure.raw = as.data.frame(measure.raw);

measure.clean = measure.raw;
measure.clean = as.data.frame(measure.clean);

dim(measure.clean);
summary(measure.clean);

measure.clean;


# for (row in 1:nrow(measure.clean)){
#   if (measure.clean$notes[row] == 'NaN') {
#   measure.clean$notes[row] <- 'no note';
#   }
# }


# 428 entries
# then remove remaining NA rows
#measure.clean <- na.omit(measure.clean);
#measure.clean; # only 176 entries left


```
## Average values
For data points that have a right and left measurement, the average will be taken. When there is only one measurement, that one will be taken. This enables to get a uniform set of data without missing values for those entries.
```{r, chunk-get-average-values}

# take one given value of left or right OR take the average of them both when given

getOne = c("hand.length", "hand.width", "hand.elbow", "elbow.armpit", "arm.reach", "foot.length", "floor.kneepit", "floor.hip", "floor.armpit");
n.rows = dim(measure.clean)[1];

for(one in getOne)
  {
  measure.clean[one] = NA;
  }
  
for(i in 1:n.rows)
  {  
  measure.row = measure.clean[i,];
  for(one in getOne)
    {
    nidx = getIndexOfDataFrameColumns(measure.clean, one);
    
    myleft = paste0(one,".left");
      lidx = getIndexOfDataFrameColumns(measure.row, myleft);
    myright = paste0(one,".right");
      ridx = getIndexOfDataFrameColumns(measure.row, myleft);
    
      # print(paste0(
      #             "left: ",myleft," --> ",lidx,
      #             " right: ",myright," --> ",ridx
      #             )
      #       );
      
      row.m = mean(
            c(as.numeric(unlist(measure.row[lidx])),
            as.numeric(unlist(measure.row[ridx]))),
            na.rm=TRUE);
      
    measure.clean[i,nidx] =  row.m;
    }
  }

#str(measure); # lot's of columns ...

measure.clean;
```


## Leave only average values
In the step above new columns have been created and added to the data frame measure.clean with the average values of left and right. I only want to keep those and get rid of the lett and right columns instead. This re-arrangement will be done now.
```{r, chunk-re-arranging-data-frame}

# determine if this separation above will give the same as separating by head proportions
measure.clean = measure.clean[,-(7:16), drop=FALSE];
measure.clean = measure.clean[,-(8:13), drop=FALSE];
measure.clean = measure.clean[,-(9:10), drop=FALSE];


# re-arrange columns
measure.clean = measure.clean[,c(1,2,3,4,5,6,20,21,22,23,24,7,25,26,27,8,28,9,10,11,12,13,14,15,16,17,18,19)];

measure.clean;
```



## Unity among gender notation
In the collected data, there have been used different notations for 'female' and 'male'. This will cause problems in further analyses and it therefore needs to be adjusted to an overall standard.
```{r, chunk-gender}

# make same gender notation
measure.clean$gender <- tolower(measure.clean$gender);

measure.clean$gender[measure.clean$gender == 'f'] <- 'female';
measure.clean$gender[measure.clean$gender == 'm'] <- 'male';

measure.clean;
```


## Converting units to cm
Since not all data has been collected in the same units, this has to be fixed in order to compare the data properly. Units used are inches and cm. I have decided to go with cm, so I convert inches to cm, where 1 inch equals to 2.54 cm.
```{r, chunk-unit-conversion}

# same units - convert to cm - 1 inch is 2.54 cm
for (row in 1:nrow(measure.clean)) { # Iterate through each row
  if (measure.clean$units[row] == 'inches' || measure.clean$units[row] == 'in' || measure.clean$units[row] == 'Inch') { # When units is in cm
    measure.clean[row, 4:17] <- measure.clean[row, 4:17]*2.54; # Replace measurements with cm equivalent
    measure.clean$units[row] <- 'cm';
  }
}

measure.clean;
```


## Remove Outliers
This step enables to clean up the data even more such that it has only accurate and reasonable data.
```{r, chunk-outliers}
# 
# # install the package 
# install.packages("ggstatsplot");
# 
# # Load the package
# #library(ggstatsplot);
# 
# # Create a boxplot of the dataset, outliers are shown as two distinct points
# boxplot(measure.clean)$out;
# 
# #Create a boxplot that labels the outliers  
# #ggbetweenstats(warpbreaks, wool, breaks, outlier.tagging = TRUE);
# 
# 
# Q <- quantile(measure.clean, probs=c(.1, .9), na.rm = TRUE);
# iqr <- IQR(measure.clean);
# 
# up <-  Q[2]+1.5*iqr; # Upper Range  
# low<- Q[1]-1.5*iqr; # Lower Range
# 
# eliminated<- subset(measure.clean, measure.clean > (Q[1] - 1.5*iqr) & measure.clean < (Q[2]+1.5*iqr));
# 
# # ggbetweenstats(eliminated, wool, breaks, outlier.tagging = TRUE) 


# create a for loop to get over each column and eliminate outliers
# 
# for (columns in 4:17) {
#    Q1 <- quantile(measure.clean[[columns]], 0.25);
#    Q3 <- quantile(measure.clean[[columns]], 0.75);
#    IQR <- IQR(measure.clean[[columns]]);
# # boxplot(measure.clean$hand.length);
#    no_outliers <- subset(measure.clean, measure.clean[[columns]]>(Q1 - 1.5*IQR) & measure.clean[[columns]]<(Q3 +1.5*IQR));
# # boxplot(no_outliers$hand.length);
# }
# 
# #colnames(measure.clean)
# 
# measure.clean;

# Q1 <- quantile(measure.clean$[hand.length], 0.25);
# Q3 <- quantile(measure.clean$hand.length, 0.75);
# IQR <- IQR(measure.clean$hand.length);
# boxplot(measure.clean$hand.length);
# 
# no_outliers <- subset(measure.clean, measure.clean$hand.length>(Q1 - 1.5*IQR) & measure.clean$hand.length<(Q3 +1.5*IQR));
# 
# boxplot(no_outliers$hand.length);


```




# Analysis 
## Proportions of head vs whole body
### Create new data frame 'measure.clean.proportions' to work on analysis
```{r, chunk-data-frame-analysis}
# new data frame
measure.clean.proportions <- as.data.frame(measure.clean);
measure.clean.proportions;
```

```{r}
plot(measure.clean.proportions$head.height.NA, measure.clean.proportions$height.NA);
```


### Assign proportions group
This analysis is based on the calculation of how many times the head height fits into the whole body height. Then the proportion values will be grouped into different groups, these are:
Group 'F': There the person is most likely a female adult because the proportions are bigger than what kids usually have, which is above 6.5.
Group 'M': There the person is most likely a male adult because the proportions are bigger than what kids usually have, which is above 6.5.
Group 'K': There the person is most likely a child (male or female) because the proportions are smaller or equal to 6.5. 
```{r, chunk-proportions-group}
# create proportion: how many times is the head in the body
measure.clean.proportions$proportions.head.and.height = measure.clean$height.NA/measure.clean$head.height.NA;

# group based on proportions
measure.clean.proportions$proportions.group[measure.clean.proportions$gender == 'female' & measure.clean.proportions$proportions.head.and.height > 6.5] <- 'F'; 
measure.clean.proportions$proportions.group[measure.clean.proportions$gender == 'male' & measure.clean.proportions$proportions.head.and.height > 6.5] <- 'M'; 
measure.clean.proportions$proportions.group[measure.clean.proportions$proportions.head.and.height <= 6.5] <- 'K';

measure.clean.proportions;
```

### Assign age group
This analysis is based on the age and gender of a person. Then these groups are created:
Group 'F': There the person is female and 11 years or older.
Group 'M': There the person is male and 11 years or older.
Group 'K': There the person is a child (male or female) because the age is 10 or younger. 
```{r, chunk-age-group}
# group into adolescent female, male and child
measure.clean.proportions$age.group[measure.clean.proportions$gender == 'female' & measure.clean.proportions$age > 10] <- 'F';
measure.clean.proportions$age.group[measure.clean.proportions$gender == 'male' & measure.clean.proportions$age > 10] <- 'M';
measure.clean.proportions$age.group[measure.clean.proportions$age < 11] <- 'K';

measure.clean.proportions;
```

### Create data frame with newly created 3 columns
```{r, chunk-data-analysis}
# new data frame
measure.proportions <- measure.clean.proportions[29:31];

measure.proportions <- na.omit(measure.proportions);
measure.proportions;
```

### Do group age and proportions match?
Here the analysis gets interesting. Now we compare if the two ways of assigning groups are matching in the assigned groups.
```{r, chunk-group-age-vs-proportions}
# now let's see if the 2 groupings give the same answer
match = 0;


for (row in 1:nrow(measure.proportions)) { # Iterate through each row
 if (measure.proportions$proportions.group[row] == measure.proportions$age.group[row]) { # When grouping is the same
    match = match + 1; # Add a match
 }
}

rows = nrow(measure.proportions);
match.ratio = match/rows;

match.percentage = match.ratio*100;
```

### What percentage of people is considered 'heroic'
This analysis is based on the calculation of how many times the head height fits into the whole body height. Then the proportion values will be grouped into different groups, these are:
Group 'F': There the person is most likely a female adult because the proportions are bigger than what kids usually have, which is above 6.5 and below or equal to 8.5. 
Group 'M': There the person is most likely a male adult because the proportions are bigger than what kids usually have, which is above 6.5 and below or equal to 8.5. 
Group 'K': There the person is most likely a child (male or female) because the proportions are smaller or equal to 6.5. 
Group 'H': There the person is most likely an adult because the proportions are heroic above 8.5. 
```{r, chunk-heroic}

# group based on proportions
measure.clean.proportions$proportions.group.2[measure.clean.proportions$gender == 'female' & measure.clean.proportions$proportions.head.and.height > 6.5 & measure.clean.proportions$proportions.head.and.height <= 8.5] <- 'F';
measure.clean.proportions$proportions.group.2[measure.clean.proportions$gender == 'male' & measure.clean.proportions$proportions.head.and.height > 6.5 & measure.clean.proportions$proportions.head.and.height <= 8.5] <- 'M';
measure.clean.proportions$proportions.group.2[measure.clean.proportions$proportions.head.and.height <= 6.5] <- 'K';
measure.clean.proportions$proportions.group.2[measure.clean.proportions$proportions.head.and.height > 8.5] <- 'H';

measure.clean.proportions;


# new data frame
measure.proportions.2 <- measure.clean.proportions[32];
measure.proportions.2 <- na.omit(measure.proportions.2);
measure.proportions.2;


# now let's see what proportion of people is considered heroic
match.h = 0;

for (row in 1:nrow(measure.proportions.2)) { # Iterate through each row
 if (measure.proportions.2$proportions.group.2[row] == 'H') { # When grouping is heroic
    match.h = match.h + 1; # Add a match
 }
}

rows = nrow(measure.proportions.2);
match.h.ratio = match.h/rows;

match.h.ratio;
match.h.percentage = match.h.ratio*100;
match.h.percentage;

# print('There are ', match.h.percentage, ' of people considered heroic. This means they have a head/hight ratio above 8.5!');
```








